#!/usr/bin/python
# -*- coding: utf-8 -*-

from Y2A_table import *
from Y2A_IO import *
import os

def printFileCannotBeFound(language):
    """
        Show the Youtube2Android JSON file cannot be found with specific language

        Arg:    language - The language variable
    """
    sentence = ["The .dat file cannot be found, please add the song first.", "找不到歌曲檔案，請先新增歌曲"]
    print sentence[language]

def showNoDownloadSong(songs, language):
    """
        Show the songs which didn't download

        Arg:    songs       - The song JSON object
                language    - The language variable
    """
    sentence = ["The following song didn't download correctly\nPlease check the list or remove them", "下面這些歌曲未成功下載，請確認未下載的歌曲以方便移除他們！"]
    print sentence[language]
    printTableOnlyX(songs, language)

def downloadSongs(songs, language, __file=JSONFileName):
    """
        Download the songs whose status are 'X'
        If there's song didn't download, it will remind at last

        Arg:    songs       - The song JSON object
                language    - The language variable
                __file      - The name of Youtube2Android JSON file
    """
    # Check if the direction folder is exist
    if not os.path.exists(musicFileAddress):
        os.mkdir(musicFileAddress)

    if not __file in os.listdir('.'):
        printFileCannotBeFound(language)
    else:
        songs = readFile()
        for i in range(len(songs["song"])):
            print "\n===================================="
            print "Download progress: ( ", i, ' / ', len(songs["song"]), ' )'
            print "===================================="
            if songs["song"][i]["status"] == 'X':
                # Download the music and construct the directory list
                originDir = os.listdir('.')
                command = 'youtube-dl -x --audio-format "mp3" ' + songs["song"][i]['url']
                os.system(command)
                afterDir = os.listdir('.')

                fileName = diff(afterDir, originDir)
                if not fileName == None:
                    # Change the name to avoid coding problem
                    if not fileName == cleanTheString(fileName):
                        os.system('mv ' + fileName[:3] + '* ' + cleanTheString(fileName))
                    fileName = cleanTheString(fileName)

                    # Revised the json
                    songs["song"][i]['name'] = removeHashCodeAndShrink(fileName)[:55]
                    songs["song"][i]['status'] = "O"
        os.system('mv *.mp3 ' + musicFileAddress)

        # Show the songs which didn't download
        isSongNoDownload = False
        for song in songs["song"]:
            if song["status"] == 'X':
                isSongNoDownload = True
        if isSongNoDownload == True:
            showNoDownloadSong(songs, language)
        saveFile(songs)

def removeHashCodeAndShrink(__string, maxLength=40):
    """
        Remove the hash code generated by youtube-dl and shrink the size of the name

        Arg:    __string    - The name you want to progress
                maxLength   - The max limit of the name
    """
    for i in range(len(__string)-1, 0, -1):
        if __string[i] == '-':
            __string = (__string[:i])[:maxLength] + __string[-4:]
            return str(__string).decode('string_escape')
    return str(__string).decode('string_escape')

def cleanTheString(__string):
    """
        Remove the character which is not the original ascii symbol
        The string will return directly if the string is valid

        Arg:    __string - The string want to clean
        Ret:    The string after removing
    """
    # Examine the string if it's a valid string
    isValid = True
    for word in __string:
        if ord(word) >= 128:
            isValid = False
    
    # Clean the invalid string
    if isValid == False:
        result = ""
        for word in __string:
            _c = ord(word)
            if _c==46 or (_c>47 and _c<58) or (_c>64 and _c<91) or (_c>96 and _c<123):
                result += word
        return result
    else:
        return __string
